//! AMBER inpcrd (coordinate/restart) file parser
//!
//! Parses AMBER7 format coordinate files generated by tleap or MD simulations.
//!
//! ## Format
//! - Line 1: Title
//! - Line 2: Number of atoms (and optionally time)
//! - Lines 3+: Coordinates (6 values per line, 12.7 format)
//! - Optional: Velocities (same format as coordinates)
//! - Optional: Box dimensions (6 values)
//!
//! ## Usage
//! ```ignore
//! let inpcrd = AmberInpcrd::from_file("system.inpcrd")?;
//! let positions = inpcrd.positions(); // [[x, y, z], ...]
//! ```

use anyhow::{anyhow, Context, Result};
use std::fs;
use std::path::Path;

/// AMBER coordinate file (inpcrd/rst7)
#[derive(Debug, Clone)]
pub struct AmberInpcrd {
    /// Title line
    pub title: String,

    /// Number of atoms
    pub n_atoms: usize,

    /// Simulation time (if from restart file)
    pub time: Option<f64>,

    /// Atomic coordinates in Angstroms (flat: [x1, y1, z1, x2, y2, z2, ...])
    pub coords: Vec<f64>,

    /// Velocities if present (same format as coords)
    pub velocities: Option<Vec<f64>>,

    /// Box dimensions [a, b, c, alpha, beta, gamma] if periodic
    pub box_dimensions: Option<[f64; 6]>,
}

impl AmberInpcrd {
    /// Parse an AMBER inpcrd/rst7 file
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = fs::read_to_string(path.as_ref())
            .with_context(|| format!("Failed to read inpcrd file: {:?}", path.as_ref()))?;
        Self::parse(&content)
    }

    /// Parse inpcrd content from string
    pub fn parse(content: &str) -> Result<Self> {
        let lines: Vec<&str> = content.lines().collect();

        if lines.len() < 2 {
            return Err(anyhow!("inpcrd file too short"));
        }

        // Line 1: Title
        let title = lines[0].to_string();

        // Line 2: natom [time]
        let parts: Vec<&str> = lines[1].split_whitespace().collect();
        if parts.is_empty() {
            return Err(anyhow!("Missing atom count in inpcrd"));
        }

        let n_atoms: usize = parts[0]
            .parse()
            .with_context(|| format!("Failed to parse atom count: {}", parts[0]))?;

        let time = if parts.len() > 1 {
            parts[1].parse().ok()
        } else {
            None
        };

        // Calculate expected number of coordinate values
        let n_coords = n_atoms * 3;
        let coords_per_line = 6;
        let coord_lines = (n_coords + coords_per_line - 1) / coords_per_line;

        // Parse coordinates (12.7 fixed format, 6 per line)
        let mut coords = Vec::with_capacity(n_coords);
        for i in 0..coord_lines {
            let line_idx = 2 + i;
            if line_idx >= lines.len() {
                return Err(anyhow!(
                    "Unexpected end of file reading coordinates at line {}",
                    line_idx
                ));
            }
            parse_fixed_width_line(lines[line_idx], 12, &mut coords)?;
        }

        // Truncate to exact number needed
        coords.truncate(n_coords);

        if coords.len() != n_coords {
            return Err(anyhow!(
                "Expected {} coordinates, got {}",
                n_coords,
                coords.len()
            ));
        }

        // Check for velocities (same number of lines as coordinates)
        let vel_start = 2 + coord_lines;
        let velocities = if vel_start + coord_lines <= lines.len() {
            // Check if next section looks like velocities (not box dimensions)
            let first_vel_line = lines.get(vel_start).unwrap_or(&"");
            let vel_values: Result<Vec<f64>> =
                first_vel_line.split_whitespace().take(6).map(|s| {
                    s.replace('D', "E").replace('d', "e").parse().map_err(|_| anyhow!("parse error"))
                }).collect();

            // If we can parse 6 values and there are more lines, assume velocities
            if vel_values.is_ok() && lines.len() >= vel_start + coord_lines {
                let mut vels = Vec::with_capacity(n_coords);
                for i in 0..coord_lines {
                    let line_idx = vel_start + i;
                    if line_idx < lines.len() {
                        let _ = parse_fixed_width_line(lines[line_idx], 12, &mut vels);
                    }
                }
                if vels.len() >= n_coords {
                    vels.truncate(n_coords);
                    Some(vels)
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        // Check for box dimensions (last line with 6 values)
        let box_dimensions = lines.last().and_then(|line| {
            let values: Vec<f64> = line
                .split_whitespace()
                .filter_map(|s| s.replace('D', "E").replace('d', "e").parse().ok())
                .collect();
            if values.len() == 6 {
                Some([values[0], values[1], values[2], values[3], values[4], values[5]])
            } else if values.len() == 3 {
                // Sometimes only a, b, c are given (assume orthorhombic)
                Some([values[0], values[1], values[2], 90.0, 90.0, 90.0])
            } else {
                None
            }
        });

        Ok(Self {
            title,
            n_atoms,
            time,
            coords,
            velocities,
            box_dimensions,
        })
    }

    /// Get atomic positions as [[x, y, z], ...] array
    pub fn positions(&self) -> Vec<[f64; 3]> {
        self.coords
            .chunks(3)
            .map(|c| [c[0], c[1], c[2]])
            .collect()
    }

    /// Get positions as flat array [x1, y1, z1, x2, y2, z2, ...]
    pub fn positions_flat(&self) -> &[f64] {
        &self.coords
    }

    /// Get velocities as [[vx, vy, vz], ...] if present
    pub fn velocities_xyz(&self) -> Option<Vec<[f64; 3]>> {
        self.velocities.as_ref().map(|vels| {
            vels.chunks(3).map(|c| [c[0], c[1], c[2]]).collect()
        })
    }

    /// Check if coordinates have velocities
    pub fn has_velocities(&self) -> bool {
        self.velocities.is_some()
    }

    /// Check if system is periodic
    pub fn is_periodic(&self) -> bool {
        self.box_dimensions.is_some()
    }

    /// Get box vectors for periodic systems
    pub fn box_vectors(&self) -> Option<[[f64; 3]; 3]> {
        self.box_dimensions.map(|dims| {
            let [a, b, c, alpha, beta, gamma] = dims;

            // Convert angles to radians
            let alpha_rad = alpha.to_radians();
            let beta_rad = beta.to_radians();
            let gamma_rad = gamma.to_radians();

            // Triclinic box vectors
            let ax = a;
            let bx = b * gamma_rad.cos();
            let by = b * gamma_rad.sin();
            let cx = c * beta_rad.cos();
            let cy = c * (alpha_rad.cos() - beta_rad.cos() * gamma_rad.cos()) / gamma_rad.sin();
            let cz = (c * c - cx * cx - cy * cy).sqrt();

            [[ax, 0.0, 0.0], [bx, by, 0.0], [cx, cy, cz]]
        })
    }
}

/// Parse fixed-width values from a line
fn parse_fixed_width_line(line: &str, width: usize, output: &mut Vec<f64>) -> Result<()> {
    let chars: Vec<char> = line.chars().collect();

    for chunk in chars.chunks(width) {
        let s: String = chunk.iter().collect();
        let trimmed = s.trim();
        if trimmed.is_empty() {
            continue;
        }

        // Handle Fortran exponential notation
        let normalized = trimmed.replace('D', "E").replace('d', "e");
        let value: f64 = normalized
            .parse()
            .with_context(|| format!("Failed to parse coordinate value: '{}'", trimmed))?;
        output.push(value);
    }

    Ok(())
}

/// Combined AMBER system with topology and coordinates
#[derive(Debug, Clone)]
pub struct AmberSystem {
    pub prmtop: super::amber_prmtop::AmberPrmtop,
    pub inpcrd: AmberInpcrd,
}

impl AmberSystem {
    /// Create system from prmtop and inpcrd files
    pub fn from_files<P: AsRef<Path>>(prmtop_path: P, inpcrd_path: P) -> Result<Self> {
        let prmtop = super::amber_prmtop::AmberPrmtop::from_file(&prmtop_path)?;
        let inpcrd = AmberInpcrd::from_file(&inpcrd_path)?;

        // Validate consistency
        if prmtop.n_atoms() != inpcrd.n_atoms {
            return Err(anyhow!(
                "Atom count mismatch: prmtop has {}, inpcrd has {}",
                prmtop.n_atoms(),
                inpcrd.n_atoms
            ));
        }

        Ok(Self { prmtop, inpcrd })
    }

    /// Get number of atoms
    pub fn n_atoms(&self) -> usize {
        self.prmtop.n_atoms()
    }

    /// Get atomic positions
    pub fn positions(&self) -> Vec<[f64; 3]> {
        self.inpcrd.positions()
    }

    /// Get atomic masses
    pub fn masses(&self) -> &[f64] {
        &self.prmtop.masses
    }

    /// Get atomic charges
    pub fn charges(&self) -> &[f64] {
        &self.prmtop.charges
    }

    /// Get all bonds with parameters
    pub fn bonds(&self) -> Vec<(usize, usize, f64, f64)> {
        self.prmtop.get_bonds()
    }

    /// Get all angles with parameters
    pub fn angles(&self) -> Vec<(usize, usize, usize, f64, f64)> {
        self.prmtop.get_angles()
    }

    /// Get all dihedrals with parameters
    pub fn dihedrals(&self) -> Vec<(usize, usize, usize, usize, f64, f64, f64, bool)> {
        self.prmtop.get_dihedrals()
    }

    /// Get LJ parameters per atom
    pub fn lj_params(&self) -> Vec<(f64, f64)> {
        self.prmtop.get_atom_lj_params()
    }

    /// Check if system is periodic
    pub fn is_periodic(&self) -> bool {
        self.prmtop.is_periodic() || self.inpcrd.is_periodic()
    }

    /// Get box dimensions if periodic
    pub fn box_dimensions(&self) -> Option<[f64; 6]> {
        self.inpcrd.box_dimensions.or(self.prmtop.box_dimensions)
    }

    /// Export to flat arrays for GPU kernel
    pub fn to_gpu_arrays(&self) -> GpuSystemArrays {
        let positions = self.inpcrd.positions();
        let n_atoms = self.n_atoms();

        // Flatten positions
        let positions_flat: Vec<f32> = positions
            .iter()
            .flat_map(|p| [p[0] as f32, p[1] as f32, p[2] as f32])
            .collect();

        // Masses and charges
        let masses: Vec<f32> = self.prmtop.masses.iter().map(|&m| m as f32).collect();
        let charges: Vec<f32> = self.prmtop.charges.iter().map(|&c| c as f32).collect();

        // LJ parameters
        let lj = self.prmtop.get_atom_lj_params();
        let lj_sigma: Vec<f32> = lj.iter().map(|(s, _)| *s as f32).collect();
        let lj_epsilon: Vec<f32> = lj.iter().map(|(_, e)| *e as f32).collect();

        // Bonds
        let bonds = self.prmtop.get_bonds();
        let bond_i: Vec<u32> = bonds.iter().map(|(i, _, _, _)| *i as u32).collect();
        let bond_j: Vec<u32> = bonds.iter().map(|(_, j, _, _)| *j as u32).collect();
        let bond_k: Vec<f32> = bonds.iter().map(|(_, _, k, _)| *k as f32).collect();
        let bond_r0: Vec<f32> = bonds.iter().map(|(_, _, _, r0)| *r0 as f32).collect();

        // Angles
        let angles = self.prmtop.get_angles();
        let angle_i: Vec<u32> = angles.iter().map(|(i, _, _, _, _)| *i as u32).collect();
        let angle_j: Vec<u32> = angles.iter().map(|(_, j, _, _, _)| *j as u32).collect();
        let angle_k: Vec<u32> = angles.iter().map(|(_, _, k, _, _)| *k as u32).collect();
        let angle_force_k: Vec<f32> = angles.iter().map(|(_, _, _, k, _)| *k as f32).collect();
        let angle_theta0: Vec<f32> = angles.iter().map(|(_, _, _, _, t)| *t as f32).collect();

        // Dihedrals
        let dihedrals = self.prmtop.get_dihedrals();
        let dihedral_i: Vec<u32> = dihedrals.iter().map(|(i, _, _, _, _, _, _, _)| *i as u32).collect();
        let dihedral_j: Vec<u32> = dihedrals.iter().map(|(_, j, _, _, _, _, _, _)| *j as u32).collect();
        let dihedral_k: Vec<u32> = dihedrals.iter().map(|(_, _, k, _, _, _, _, _)| *k as u32).collect();
        let dihedral_l: Vec<u32> = dihedrals.iter().map(|(_, _, _, l, _, _, _, _)| *l as u32).collect();
        let dihedral_force_k: Vec<f32> = dihedrals.iter().map(|(_, _, _, _, k, _, _, _)| *k as f32).collect();
        let dihedral_n: Vec<f32> = dihedrals.iter().map(|(_, _, _, _, _, n, _, _)| *n as f32).collect();
        let dihedral_phase: Vec<f32> = dihedrals.iter().map(|(_, _, _, _, _, _, p, _)| *p as f32).collect();

        // Box dimensions
        let box_dims = self.box_dimensions().map(|d| [d[0] as f32, d[1] as f32, d[2] as f32]);

        GpuSystemArrays {
            n_atoms,
            positions: positions_flat,
            masses,
            charges,
            lj_sigma,
            lj_epsilon,
            n_bonds: bonds.len(),
            bond_i,
            bond_j,
            bond_k,
            bond_r0,
            n_angles: angles.len(),
            angle_i,
            angle_j,
            angle_k,
            angle_force_k,
            angle_theta0,
            n_dihedrals: dihedrals.len(),
            dihedral_i,
            dihedral_j,
            dihedral_k,
            dihedral_l,
            dihedral_force_k,
            dihedral_n,
            dihedral_phase,
            box_dimensions: box_dims,
        }
    }
}

/// Flat arrays ready for GPU upload
#[derive(Debug, Clone)]
pub struct GpuSystemArrays {
    pub n_atoms: usize,
    pub positions: Vec<f32>,
    pub masses: Vec<f32>,
    pub charges: Vec<f32>,
    pub lj_sigma: Vec<f32>,
    pub lj_epsilon: Vec<f32>,

    pub n_bonds: usize,
    pub bond_i: Vec<u32>,
    pub bond_j: Vec<u32>,
    pub bond_k: Vec<f32>,
    pub bond_r0: Vec<f32>,

    pub n_angles: usize,
    pub angle_i: Vec<u32>,
    pub angle_j: Vec<u32>,
    pub angle_k: Vec<u32>,
    pub angle_force_k: Vec<f32>,
    pub angle_theta0: Vec<f32>,

    pub n_dihedrals: usize,
    pub dihedral_i: Vec<u32>,
    pub dihedral_j: Vec<u32>,
    pub dihedral_k: Vec<u32>,
    pub dihedral_l: Vec<u32>,
    pub dihedral_force_k: Vec<f32>,
    pub dihedral_n: Vec<f32>,
    pub dihedral_phase: Vec<f32>,

    pub box_dimensions: Option<[f32; 3]>,
}

impl GpuSystemArrays {
    /// Print summary statistics
    pub fn summary(&self) -> String {
        format!(
            "AmberSystem: {} atoms, {} bonds, {} angles, {} dihedrals{}",
            self.n_atoms,
            self.n_bonds,
            self.n_angles,
            self.n_dihedrals,
            if self.box_dimensions.is_some() {
                format!(" (periodic: {:?})", self.box_dimensions.unwrap())
            } else {
                " (non-periodic)".to_string()
            }
        )
    }
}

/// Data formatted for AmberMegaFusedHmc::upload_topology()
#[derive(Debug, Clone)]
pub struct GpuTopologyData {
    /// Flat position array [x0, y0, z0, x1, y1, z1, ...]
    pub positions: Vec<f32>,

    /// Bonds: (atom_i, atom_j, k, r0)
    pub bonds: Vec<(usize, usize, f32, f32)>,

    /// Angles: (atom_i, atom_j, atom_k, force_k, theta0)
    pub angles: Vec<(usize, usize, usize, f32, f32)>,

    /// Dihedrals: (atom_i, atom_j, atom_k, atom_l, force_k, periodicity, phase)
    pub dihedrals: Vec<(usize, usize, usize, usize, f32, f32, f32)>,

    /// Non-bonded params per atom: (sigma, epsilon, charge, mass)
    pub nb_params: Vec<(f32, f32, f32, f32)>,

    /// Exclusion list per atom (bonded 1-2 and 1-3 pairs)
    pub exclusions: Vec<std::collections::HashSet<usize>>,

    /// Number of atoms
    pub n_atoms: usize,

    /// Box dimensions if periodic [x, y, z]
    pub box_dimensions: Option<[f32; 3]>,
}

impl AmberSystem {
    /// Convert to format ready for AmberMegaFusedHmc::upload_topology()
    ///
    /// This method produces all the data structures needed to initialize
    /// the GPU MD engine with AMBER-validated parameters.
    pub fn to_gpu_topology(&self) -> GpuTopologyData {
        use std::collections::HashSet;

        let n_atoms = self.n_atoms();

        // Positions as flat f32 array
        let positions: Vec<f32> = self.inpcrd.coords
            .iter()
            .map(|&c| c as f32)
            .collect();

        // Bonds: (i, j, k, r0)
        let bonds: Vec<(usize, usize, f32, f32)> = self.prmtop.get_bonds()
            .into_iter()
            .map(|(i, j, k, r0)| (i, j, k as f32, r0 as f32))
            .collect();

        // Angles: (i, j, k, force_k, theta0)
        let angles: Vec<(usize, usize, usize, f32, f32)> = self.prmtop.get_angles()
            .into_iter()
            .map(|(i, j, k, force_k, theta0)| (i, j, k, force_k as f32, theta0 as f32))
            .collect();

        // Dihedrals: (i, j, k, l, force_k, n, phase)
        // Note: We skip improper dihedrals for now, they use different energy function
        let dihedrals: Vec<(usize, usize, usize, usize, f32, f32, f32)> = self.prmtop.get_dihedrals()
            .into_iter()
            .filter(|(_, _, _, _, _, _, _, is_improper)| !is_improper)
            .map(|(i, j, k, l, force_k, n, phase, _)| {
                (i, j, k, l, force_k as f32, n as f32, phase as f32)
            })
            .collect();

        // Non-bonded params: (sigma, epsilon, charge, mass)
        let lj_params = self.prmtop.get_atom_lj_params();
        let nb_params: Vec<(f32, f32, f32, f32)> = (0..n_atoms)
            .map(|i| {
                let (sigma, epsilon) = lj_params.get(i).copied().unwrap_or((0.0, 0.0));
                let charge = self.prmtop.charges.get(i).copied().unwrap_or(0.0);
                let mass = self.prmtop.masses.get(i).copied().unwrap_or(1.0);
                (sigma as f32, epsilon as f32, charge as f32, mass as f32)
            })
            .collect();

        // Build exclusion sets (1-2 and 1-3 bonded pairs)
        let mut exclusions: Vec<HashSet<usize>> = vec![HashSet::new(); n_atoms];

        // Add 1-2 (bonded) exclusions
        for &(i, j, _, _) in &bonds {
            exclusions[i].insert(j);
            exclusions[j].insert(i);
        }

        // Add 1-3 (angle) exclusions
        for &(i, _, k, _, _) in &angles {
            exclusions[i].insert(k);
            exclusions[k].insert(i);
        }

        // Also use the exclusion list from prmtop if available
        for atom_idx in 0..n_atoms {
            for excluded in self.prmtop.get_exclusions(atom_idx) {
                if excluded < n_atoms {
                    exclusions[atom_idx].insert(excluded);
                    exclusions[excluded].insert(atom_idx);
                }
            }
        }

        // Box dimensions
        let box_dimensions = self.box_dimensions()
            .map(|d| [d[0] as f32, d[1] as f32, d[2] as f32]);

        GpuTopologyData {
            positions,
            bonds,
            angles,
            dihedrals,
            nb_params,
            exclusions,
            n_atoms,
            box_dimensions,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_fixed_width() {
        let line = "   1.2345678  -2.3456789   3.4567890   4.5678901  -5.6789012   6.7890123";
        let mut values = Vec::new();
        parse_fixed_width_line(line, 12, &mut values).unwrap();
        assert_eq!(values.len(), 6);
        assert!((values[0] - 1.2345678).abs() < 1e-6);
        assert!((values[1] - (-2.3456789)).abs() < 1e-6);
    }

    #[test]
    fn test_parse_minimal_inpcrd() {
        let content = "Test system
    3
   0.0000000   0.0000000   0.0000000   1.0000000   0.0000000   0.0000000
   2.0000000   0.0000000   0.0000000
";
        let inpcrd = AmberInpcrd::parse(content).unwrap();
        assert_eq!(inpcrd.n_atoms, 3);
        assert_eq!(inpcrd.coords.len(), 9);
        assert!((inpcrd.coords[0]).abs() < 1e-6);
        assert!((inpcrd.coords[3] - 1.0).abs() < 1e-6);
        assert!((inpcrd.coords[6] - 2.0).abs() < 1e-6);
    }
}
