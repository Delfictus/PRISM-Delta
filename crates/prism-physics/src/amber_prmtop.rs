//! AMBER prmtop (topology) file parser
//!
//! Parses AMBER7 format topology files generated by tleap.
//! These files contain all force field parameters needed for MD simulation.
//!
//! ## Key Sections Parsed
//! - POINTERS: System sizes (natom, ntypes, nbonh, etc.)
//! - ATOM_NAME, CHARGE, MASS: Per-atom properties
//! - BOND/ANGLE/DIHEDRAL parameters: Bonded interactions
//! - LENNARD_JONES: Non-bonded LJ parameters
//! - EXCLUDED_ATOMS: Exclusion lists for non-bonded
//!
//! ## Usage
//! ```ignore
//! let prmtop = AmberPrmtop::from_file("system.prmtop")?;
//! let inpcrd = AmberInpcrd::from_file("system.inpcrd")?;
//! let system = AmberSystem::new(prmtop, inpcrd)?;
//! ```

use anyhow::{anyhow, Context, Result};
use std::collections::HashMap;
use std::fs;
use std::path::Path;

/// AMBER topology (prmtop) containing all force field parameters
#[derive(Debug, Clone)]
pub struct AmberPrmtop {
    /// Title/version string
    pub title: String,

    /// System dimensions from POINTERS section
    pub pointers: Pointers,

    /// Atom names (4 characters each)
    pub atom_names: Vec<String>,

    /// Atomic charges (already divided by 18.2223 to get elementary charge units)
    pub charges: Vec<f64>,

    /// Atomic masses in amu
    pub masses: Vec<f64>,

    /// Atom type indices (1-based, for LJ lookup)
    pub atom_type_indices: Vec<usize>,

    /// Residue labels
    pub residue_labels: Vec<String>,

    /// Residue pointers (first atom index of each residue, 1-based)
    pub residue_pointers: Vec<usize>,

    /// Bond parameters: (force constant kcal/mol/A^2, equilibrium distance A)
    pub bond_params: Vec<(f64, f64)>,

    /// Bonds including hydrogen: (atom_i, atom_j, param_index) - indices are 3*atom_index
    pub bonds_inc_h: Vec<(usize, usize, usize)>,

    /// Bonds without hydrogen
    pub bonds_without_h: Vec<(usize, usize, usize)>,

    /// Angle parameters: (force constant kcal/mol/rad^2, equilibrium angle rad)
    pub angle_params: Vec<(f64, f64)>,

    /// Angles including hydrogen: (i, j, k, param_index)
    pub angles_inc_h: Vec<(usize, usize, usize, usize)>,

    /// Angles without hydrogen
    pub angles_without_h: Vec<(usize, usize, usize, usize)>,

    /// Dihedral parameters: (force constant, periodicity, phase)
    pub dihedral_params: Vec<(f64, f64, f64)>,

    /// Dihedrals including hydrogen: (i, j, k, l, param_index)
    /// Note: negative indices indicate 1-4 interaction should be excluded
    pub dihedrals_inc_h: Vec<(i32, i32, i32, i32, usize)>,

    /// Dihedrals without hydrogen
    pub dihedrals_without_h: Vec<(i32, i32, i32, i32, usize)>,

    /// Lennard-Jones A coefficients (for type pairs)
    pub lj_acoef: Vec<f64>,

    /// Lennard-Jones B coefficients (for type pairs)
    pub lj_bcoef: Vec<f64>,

    /// Number of excluded atoms for each atom
    pub num_excluded: Vec<usize>,

    /// Excluded atoms list (concatenated, use num_excluded to split)
    pub excluded_atoms: Vec<usize>,

    /// Atom type names
    pub amber_atom_types: Vec<String>,

    /// Box dimensions if periodic (a, b, c, alpha, beta, gamma)
    pub box_dimensions: Option<[f64; 6]>,
}

/// System size pointers from POINTERS section
#[derive(Debug, Clone, Default)]
pub struct Pointers {
    /// Number of atoms
    pub natom: usize,
    /// Number of atom types
    pub ntypes: usize,
    /// Number of bonds containing hydrogen
    pub nbonh: usize,
    /// Number of bonds not containing hydrogen
    pub mbona: usize,
    /// Number of angles containing hydrogen
    pub ntheth: usize,
    /// Number of angles not containing hydrogen
    pub mtheta: usize,
    /// Number of dihedrals containing hydrogen
    pub nphih: usize,
    /// Number of dihedrals not containing hydrogen
    pub mphia: usize,
    /// Number of excluded atoms
    pub nnb: usize,
    /// Number of residues
    pub nres: usize,
    /// Number of bond types
    pub numbnd: usize,
    /// Number of angle types
    pub numang: usize,
    /// Number of dihedral types
    pub nptra: usize,
    /// IFBOX flag (0=no box, 1=orthorhombic, 2=truncated octahedron)
    pub ifbox: usize,
    /// Number of atoms in largest residue
    pub nmxrs: usize,
    /// IFCAP flag for cap option
    pub ifcap: usize,
}

impl AmberPrmtop {
    /// Parse an AMBER prmtop file
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let content = fs::read_to_string(path.as_ref())
            .with_context(|| format!("Failed to read prmtop file: {:?}", path.as_ref()))?;
        Self::parse(&content)
    }

    /// Parse prmtop content from string
    pub fn parse(content: &str) -> Result<Self> {
        let sections = parse_sections(content)?;

        // Parse POINTERS first - we need these for array sizes
        let pointers = parse_pointers(
            sections
                .get("POINTERS")
                .ok_or_else(|| anyhow!("Missing POINTERS section"))?,
        )?;

        // Parse title
        let title = sections
            .get("TITLE")
            .map(|s| s.trim().to_string())
            .unwrap_or_default();

        // Parse atom properties
        let atom_names = parse_strings(
            sections
                .get("ATOM_NAME")
                .ok_or_else(|| anyhow!("Missing ATOM_NAME section"))?,
            4,
        )?;

        // Charges are stored multiplied by 18.2223 (AMBER internal units)
        let raw_charges = parse_floats(
            sections
                .get("CHARGE")
                .ok_or_else(|| anyhow!("Missing CHARGE section"))?,
        )?;
        let charges: Vec<f64> = raw_charges.iter().map(|c| c / 18.2223).collect();

        let masses = parse_floats(
            sections
                .get("MASS")
                .ok_or_else(|| anyhow!("Missing MASS section"))?,
        )?;

        let atom_type_indices = parse_ints(
            sections
                .get("ATOM_TYPE_INDEX")
                .ok_or_else(|| anyhow!("Missing ATOM_TYPE_INDEX section"))?,
        )?;

        // Parse residue info
        let residue_labels = parse_strings(
            sections
                .get("RESIDUE_LABEL")
                .ok_or_else(|| anyhow!("Missing RESIDUE_LABEL section"))?,
            4,
        )?;

        let residue_pointers = parse_ints(
            sections
                .get("RESIDUE_POINTER")
                .ok_or_else(|| anyhow!("Missing RESIDUE_POINTER section"))?,
        )?;

        // Parse bond parameters
        let bond_force_constants = parse_floats(
            sections
                .get("BOND_FORCE_CONSTANT")
                .unwrap_or(&String::new()),
        )?;
        let bond_equil_values =
            parse_floats(sections.get("BOND_EQUIL_VALUE").unwrap_or(&String::new()))?;
        let bond_params: Vec<(f64, f64)> = bond_force_constants
            .into_iter()
            .zip(bond_equil_values)
            .collect();

        // Parse bonds
        let bonds_inc_h = parse_bond_list(
            sections.get("BONDS_INC_HYDROGEN").unwrap_or(&String::new()),
        )?;
        let bonds_without_h = parse_bond_list(
            sections
                .get("BONDS_WITHOUT_HYDROGEN")
                .unwrap_or(&String::new()),
        )?;

        // Parse angle parameters
        let angle_force_constants = parse_floats(
            sections
                .get("ANGLE_FORCE_CONSTANT")
                .unwrap_or(&String::new()),
        )?;
        let angle_equil_values =
            parse_floats(sections.get("ANGLE_EQUIL_VALUE").unwrap_or(&String::new()))?;
        let angle_params: Vec<(f64, f64)> = angle_force_constants
            .into_iter()
            .zip(angle_equil_values)
            .collect();

        // Parse angles
        let angles_inc_h = parse_angle_list(
            sections.get("ANGLES_INC_HYDROGEN").unwrap_or(&String::new()),
        )?;
        let angles_without_h = parse_angle_list(
            sections
                .get("ANGLES_WITHOUT_HYDROGEN")
                .unwrap_or(&String::new()),
        )?;

        // Parse dihedral parameters
        let dihedral_force_k = parse_floats(
            sections
                .get("DIHEDRAL_FORCE_CONSTANT")
                .unwrap_or(&String::new()),
        )?;
        let dihedral_periodicity = parse_floats(
            sections
                .get("DIHEDRAL_PERIODICITY")
                .unwrap_or(&String::new()),
        )?;
        let dihedral_phase =
            parse_floats(sections.get("DIHEDRAL_PHASE").unwrap_or(&String::new()))?;

        let dihedral_params: Vec<(f64, f64, f64)> = dihedral_force_k
            .into_iter()
            .zip(dihedral_periodicity)
            .zip(dihedral_phase)
            .map(|((k, n), phi)| (k, n, phi))
            .collect();

        // Parse dihedrals (signed integers for 1-4 exclusion handling)
        let dihedrals_inc_h = parse_dihedral_list(
            sections
                .get("DIHEDRALS_INC_HYDROGEN")
                .unwrap_or(&String::new()),
        )?;
        let dihedrals_without_h = parse_dihedral_list(
            sections
                .get("DIHEDRALS_WITHOUT_HYDROGEN")
                .unwrap_or(&String::new()),
        )?;

        // Parse LJ parameters
        let lj_acoef = parse_floats(
            sections
                .get("LENNARD_JONES_ACOEF")
                .unwrap_or(&String::new()),
        )?;
        let lj_bcoef = parse_floats(
            sections
                .get("LENNARD_JONES_BCOEF")
                .unwrap_or(&String::new()),
        )?;

        // Parse exclusions
        let num_excluded = parse_ints(
            sections
                .get("NUMBER_EXCLUDED_ATOMS")
                .unwrap_or(&String::new()),
        )?;
        let excluded_atoms =
            parse_ints(sections.get("EXCLUDED_ATOMS_LIST").unwrap_or(&String::new()))?;

        // Parse atom types
        let amber_atom_types = parse_strings(
            sections.get("AMBER_ATOM_TYPE").unwrap_or(&String::new()),
            4,
        )?;

        // Parse box dimensions if present
        let box_dimensions = if pointers.ifbox > 0 {
            sections.get("BOX_DIMENSIONS").and_then(|s| {
                let vals = parse_floats(s).ok()?;
                if vals.len() >= 4 {
                    // Format: beta, a, b, c (beta is usually 90.0 for orthorhombic)
                    Some([vals[1], vals[2], vals[3], vals[0], 90.0, 90.0])
                } else {
                    None
                }
            })
        } else {
            None
        };

        Ok(Self {
            title,
            pointers,
            atom_names,
            charges,
            masses,
            atom_type_indices,
            residue_labels,
            residue_pointers,
            bond_params,
            bonds_inc_h,
            bonds_without_h,
            angle_params,
            angles_inc_h,
            angles_without_h,
            dihedral_params,
            dihedrals_inc_h,
            dihedrals_without_h,
            lj_acoef,
            lj_bcoef,
            num_excluded,
            excluded_atoms,
            amber_atom_types,
            box_dimensions,
        })
    }

    /// Get number of atoms
    pub fn n_atoms(&self) -> usize {
        self.pointers.natom
    }

    /// Get number of residues
    pub fn n_residues(&self) -> usize {
        self.pointers.nres
    }

    /// Get all bonds as (atom_i, atom_j, k, r0) tuples
    pub fn get_bonds(&self) -> Vec<(usize, usize, f64, f64)> {
        let mut bonds = Vec::new();

        for &(i, j, param_idx) in &self.bonds_inc_h {
            let atom_i = i / 3;
            let atom_j = j / 3;
            if param_idx > 0 && param_idx <= self.bond_params.len() {
                let (k, r0) = self.bond_params[param_idx - 1];
                bonds.push((atom_i, atom_j, k, r0));
            }
        }

        for &(i, j, param_idx) in &self.bonds_without_h {
            let atom_i = i / 3;
            let atom_j = j / 3;
            if param_idx > 0 && param_idx <= self.bond_params.len() {
                let (k, r0) = self.bond_params[param_idx - 1];
                bonds.push((atom_i, atom_j, k, r0));
            }
        }

        bonds
    }

    /// Get all angles as (atom_i, atom_j, atom_k, force_k, theta0) tuples
    pub fn get_angles(&self) -> Vec<(usize, usize, usize, f64, f64)> {
        let mut angles = Vec::new();

        for &(i, j, k, param_idx) in &self.angles_inc_h {
            let atom_i = i / 3;
            let atom_j = j / 3;
            let atom_k = k / 3;
            if param_idx > 0 && param_idx <= self.angle_params.len() {
                let (force_k, theta0) = self.angle_params[param_idx - 1];
                angles.push((atom_i, atom_j, atom_k, force_k, theta0));
            }
        }

        for &(i, j, k, param_idx) in &self.angles_without_h {
            let atom_i = i / 3;
            let atom_j = j / 3;
            let atom_k = k / 3;
            if param_idx > 0 && param_idx <= self.angle_params.len() {
                let (force_k, theta0) = self.angle_params[param_idx - 1];
                angles.push((atom_i, atom_j, atom_k, force_k, theta0));
            }
        }

        angles
    }

    /// Get all dihedrals as (i, j, k, l, force_k, periodicity, phase, is_improper) tuples
    pub fn get_dihedrals(&self) -> Vec<(usize, usize, usize, usize, f64, f64, f64, bool)> {
        let mut dihedrals = Vec::new();

        let process = |list: &[(i32, i32, i32, i32, usize)]| {
            let mut result = Vec::new();
            for &(i, j, k, l, param_idx) in list {
                // Negative l indicates improper dihedral
                let is_improper = l < 0;
                let atom_i = (i.unsigned_abs() as usize) / 3;
                let atom_j = (j.unsigned_abs() as usize) / 3;
                let atom_k = (k.unsigned_abs() as usize) / 3;
                let atom_l = (l.unsigned_abs() as usize) / 3;

                if param_idx > 0 && param_idx <= self.dihedral_params.len() {
                    let (force_k, periodicity, phase) = self.dihedral_params[param_idx - 1];
                    result.push((
                        atom_i,
                        atom_j,
                        atom_k,
                        atom_l,
                        force_k,
                        periodicity,
                        phase,
                        is_improper,
                    ));
                }
            }
            result
        };

        dihedrals.extend(process(&self.dihedrals_inc_h));
        dihedrals.extend(process(&self.dihedrals_without_h));
        dihedrals
    }

    /// Get LJ parameters (sigma, epsilon) for atom type pair
    /// Uses combining rules: sigma = (sigma_i + sigma_j) / 2, epsilon = sqrt(eps_i * eps_j)
    pub fn get_lj_params(&self, type_i: usize, type_j: usize) -> Option<(f64, f64)> {
        let ntypes = self.pointers.ntypes;
        if type_i == 0 || type_j == 0 || type_i > ntypes || type_j > ntypes {
            return None;
        }

        // LJ coefficients are stored in a triangular matrix
        // Index = ntypes * (type_i - 1) + type_j - 1 (for type_i <= type_j)
        let (ti, tj) = if type_i <= type_j {
            (type_i, type_j)
        } else {
            (type_j, type_i)
        };

        let idx = ntypes * (ti - 1) + tj - 1;
        if idx >= self.lj_acoef.len() {
            return None;
        }

        let a = self.lj_acoef[idx];
        let b = self.lj_bcoef[idx];

        if b.abs() < 1e-10 {
            return Some((0.0, 0.0)); // No LJ interaction
        }

        // Convert from A/B coefficients to sigma/epsilon
        // A = 4 * epsilon * sigma^12
        // B = 4 * epsilon * sigma^6
        // sigma = (A/B)^(1/6), epsilon = B^2 / (4*A)
        let sigma = (a / b).powf(1.0 / 6.0);
        let epsilon = b * b / (4.0 * a);

        Some((sigma, epsilon))
    }

    /// Get per-atom LJ parameters (sigma, epsilon) in Angstroms and kcal/mol
    pub fn get_atom_lj_params(&self) -> Vec<(f64, f64)> {
        let mut params = Vec::with_capacity(self.n_atoms());

        for i in 0..self.n_atoms() {
            let type_idx = self.atom_type_indices[i];
            if let Some((sigma, epsilon)) = self.get_lj_params(type_idx, type_idx) {
                params.push((sigma, epsilon));
            } else {
                params.push((0.0, 0.0));
            }
        }

        params
    }

    /// Get residue index for an atom (0-based)
    pub fn atom_residue(&self, atom_idx: usize) -> usize {
        for (res_idx, &first_atom) in self.residue_pointers.iter().enumerate() {
            let first = first_atom - 1; // Convert to 0-based
            let last = if res_idx + 1 < self.residue_pointers.len() {
                self.residue_pointers[res_idx + 1] - 1
            } else {
                self.n_atoms()
            };
            if atom_idx >= first && atom_idx < last {
                return res_idx;
            }
        }
        0
    }

    /// Get exclusion list for an atom
    pub fn get_exclusions(&self, atom_idx: usize) -> Vec<usize> {
        if atom_idx >= self.num_excluded.len() {
            return Vec::new();
        }

        let start: usize = self.num_excluded[..atom_idx].iter().sum();
        let count = self.num_excluded[atom_idx];

        self.excluded_atoms[start..start + count]
            .iter()
            .filter(|&&x| x > 0) // 0 means no exclusion
            .map(|&x| x - 1) // Convert to 0-based
            .collect()
    }

    /// Check if system has periodic boundary conditions
    pub fn is_periodic(&self) -> bool {
        self.pointers.ifbox > 0
    }
}

/// Parse sections from prmtop content
fn parse_sections(content: &str) -> Result<HashMap<String, String>> {
    let mut sections = HashMap::new();
    let mut current_section: Option<String> = None;
    let mut current_data = String::new();

    for line in content.lines() {
        if line.starts_with("%FLAG") {
            // Save previous section
            if let Some(section) = current_section.take() {
                sections.insert(section, current_data.clone());
            }
            current_data.clear();

            // Parse new section name
            let name = line
                .strip_prefix("%FLAG")
                .map(|s| s.trim().to_string())
                .unwrap_or_default();
            current_section = Some(name);
        } else if line.starts_with("%FORMAT") {
            // Skip format line
        } else if line.starts_with("%VERSION") {
            // Skip version line
        } else if line.starts_with("%COMMENT") {
            // Skip comment
        } else if current_section.is_some() {
            current_data.push_str(line);
            current_data.push('\n');
        }
    }

    // Save last section
    if let Some(section) = current_section {
        sections.insert(section, current_data);
    }

    Ok(sections)
}

/// Parse POINTERS section (31 integers)
fn parse_pointers(data: &str) -> Result<Pointers> {
    let values = parse_ints(data)?;
    if values.len() < 31 {
        return Err(anyhow!(
            "POINTERS section too short: {} values (need 31)",
            values.len()
        ));
    }

    Ok(Pointers {
        natom: values[0],
        ntypes: values[1],
        nbonh: values[2],
        mbona: values[3],
        ntheth: values[4],
        mtheta: values[5],
        nphih: values[6],
        mphia: values[7],
        nnb: values[10],
        nres: values[11],
        numbnd: values[15],
        numang: values[16],
        nptra: values[17],
        ifbox: values[27],
        nmxrs: values[28],
        ifcap: values[29],
    })
}

/// Parse whitespace-separated integers
fn parse_ints(data: &str) -> Result<Vec<usize>> {
    data.split_whitespace()
        .map(|s| {
            s.parse::<usize>()
                .with_context(|| format!("Failed to parse integer: {}", s))
        })
        .collect()
}

/// Parse whitespace-separated floats
fn parse_floats(data: &str) -> Result<Vec<f64>> {
    if data.trim().is_empty() {
        return Ok(Vec::new());
    }

    data.split_whitespace()
        .map(|s| {
            // Handle Fortran-style exponentials (1.234D+05 -> 1.234E+05)
            let normalized = s.replace('D', "E").replace('d', "e");
            normalized
                .parse::<f64>()
                .with_context(|| format!("Failed to parse float: {}", s))
        })
        .collect()
}

/// Parse signed integers (for dihedral indices)
fn parse_signed_ints(data: &str) -> Result<Vec<i32>> {
    data.split_whitespace()
        .map(|s| {
            s.parse::<i32>()
                .with_context(|| format!("Failed to parse signed integer: {}", s))
        })
        .collect()
}

/// Parse fixed-width strings
fn parse_strings(data: &str, width: usize) -> Result<Vec<String>> {
    let mut strings = Vec::new();

    for line in data.lines() {
        let chars: Vec<char> = line.chars().collect();
        for chunk in chars.chunks(width) {
            let s: String = chunk.iter().collect();
            strings.push(s.trim().to_string());
        }
    }

    Ok(strings)
}

/// Parse bond list (3 integers per bond: i, j, param_index)
fn parse_bond_list(data: &str) -> Result<Vec<(usize, usize, usize)>> {
    let values = parse_ints(data)?;
    let mut bonds = Vec::new();

    for chunk in values.chunks(3) {
        if chunk.len() == 3 {
            bonds.push((chunk[0], chunk[1], chunk[2]));
        }
    }

    Ok(bonds)
}

/// Parse angle list (4 integers per angle: i, j, k, param_index)
fn parse_angle_list(data: &str) -> Result<Vec<(usize, usize, usize, usize)>> {
    let values = parse_ints(data)?;
    let mut angles = Vec::new();

    for chunk in values.chunks(4) {
        if chunk.len() == 4 {
            angles.push((chunk[0], chunk[1], chunk[2], chunk[3]));
        }
    }

    Ok(angles)
}

/// Parse dihedral list (5 signed integers per dihedral)
fn parse_dihedral_list(data: &str) -> Result<Vec<(i32, i32, i32, i32, usize)>> {
    let values = parse_signed_ints(data)?;
    let mut dihedrals = Vec::new();

    for chunk in values.chunks(5) {
        if chunk.len() == 5 {
            dihedrals.push((
                chunk[0],
                chunk[1],
                chunk[2],
                chunk[3],
                chunk[4] as usize,
            ));
        }
    }

    Ok(dihedrals)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_floats() {
        let data = "  1.0  2.5  -3.14  1.234E+05  5.678D-10  ";
        let values = parse_floats(data).unwrap();
        assert_eq!(values.len(), 5);
        assert!((values[0] - 1.0).abs() < 1e-10);
        assert!((values[1] - 2.5).abs() < 1e-10);
        assert!((values[2] - (-3.14)).abs() < 1e-10);
        assert!((values[3] - 123400.0).abs() < 1e-5);
        assert!((values[4] - 5.678e-10).abs() < 1e-20);
    }

    #[test]
    fn test_parse_ints() {
        let data = "  1  2  100  999  ";
        let values = parse_ints(data).unwrap();
        assert_eq!(values, vec![1, 2, 100, 999]);
    }

    #[test]
    fn test_parse_strings() {
        let data = "ALA GLY SER PRO\nCYS MET LYS ARG";
        let strings = parse_strings(data, 4).unwrap();
        assert_eq!(strings.len(), 8);
        assert_eq!(strings[0], "ALA");
        assert_eq!(strings[4], "CYS");
    }
}
